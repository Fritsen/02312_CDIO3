\section{GRASP (General Responsibilty Assignment Software Patterns)}
\todo[inline]{Thomas A: Forklar hvad vi har brugt}
Vi vil i dette afsnit beskrive de forskellige GRASP patterns og give eksempler på, hvordan vi har brugt det til implementering af vores program \cite{Larman}.
\subsection{Controller}
Vi har for overskueligeheden, og funktionaliteten i vores program, lavet en controller, \textit{Game}, der styrer alt hvad der sker. Alle kald og informationer der går på tværs af programmet går igennem vores kontroller uden at den egentlig har noget med nogen af signalerne at gøre udover at bestemme hvad der skal ske i de forskellige tilfælde. Man kan vel næsten sige at controlleren er vores lyskryds hvor en masse veje mødes og bliver omdirigeret.  
\subsection{Creater}
En creator er bogstaveligt tatlt det. Den skaber objekter af en klasse. Det er en funktion man bruger meget til at gøre programmering mere simpel og effektiv. Nedenfor kan der ses generelle situationer hvori, dette bruges:
\begin{enumerate}
\item Instancer af B indeholder aggregerede instancer af A
\item Instancer af B iagtager instancer af A
\item Instancer af B ligger tæt op af instancer af A
\item Instancer af B indeholder den igang-sættende information for instancer af A og senere krearer det
\end{enumerate}
Et godt eksempel fra vores egen kode kunne være vores Ownable klasse. Den indeholder instancer af Field. Ownable "reagere" kun på hvorvidt instancerne i Field bliver aktiveret. 
\subsubsection*{Problem}
Oprettelse af objekter, er en af de mest almindelige aktiviteter i et objektorienteret system.
\\
\subsubsection*{Problem}
Oprettelse af objekter, er en af de mest almindelige aktiviteter i et objektorienteret system.
\\
Et generelt princip til oprettelses ansvar er meget brugbart. Hvis ansvarsfordelingen bliver fordelt godt, kan man opnå \textbf{lav kobling} \textit{(Andet GRAS Pattern, der beskrives senere)}, større klarhed, indkapsling (den internne representation af et objekt, der er gemt fra kig udenfor objektets definition.) og genanvendelighed.
\subsubsection*{Generel Løsning}
Giv klasse B ansvar for at oprette en instans af klassen A, hvis et af disse udtryk er sande (Helst flere af udtrykkenne).
\begin{itemize}
\item B indeholder, eller komposit agrigerer A
\item B bruger A tæt.
\item Bhar de initialiserende data til A, som bliver sendt til A, når denne er oprettet.
\\
Dermed er B \textbf{Expert} \textit{(Andet GRAS Pattern, der beskrives senere)} for at oprette A.
\end{itemize}
\subsubsection*{Vores Løsning}
Denne tankegang har vi brugt i forbindelse med vores domænemodel. I den kan vi udlede at vores \textit{Game} bruger et \textit{GameBoard}, som indeholder flere \textit{Fields}. Vi kan dermed se at \textit{Game} er en god kandidat til at bære ansvaret for at oprette \textit{GameBoard}. \textit{GameBoard} er også oplagt til at oprette \textit{Field} objekter. Samme historie gentages i resten af modellen, så godt som muligt efter denne tankegang.
\subsection{Expert}
I vores kode har der været brug for en expert til at holde styr på vores felter på spillepladen. Derfor har vi lagret alle informationer, såsom hvad en grund koster at købe eller hvad den koster at lande på når en anden ejer den, i \textit{gameBoard} klassen. Det gør samtidigt at vi hurtigt kan komme til informationerne fra andre klasser da vi kun skal gå et sted hen for at hente informationerne. 
Man kan bruge et eksempel fra den virkelige verden. Forestil dig at du skal slå 20 dyr op. Hvis du skal slå op i en bog for hvert dyr kan det tage sin tid, i forhold til hvis du kun skal have fat i en bog.
\\
\subsection{High Cohesion (Høj binding)}
Høj binding er noget man altid stræber efter i et system. Det har vi også gjort som man kan se på vores \textit{Account} og \textit{Player} klasser. De kender til hindanden uden at de kan gøre andet end at give kommandoer. Det vil sige at Player for eksempel kan bede om data om en spiller fra Account, og modsat kan Account modtage data fra Player om en spiller. 
\subsection{Indirection}
Indirection er noget der bliver brugt i vores kode. Faktisk er vores controller \textit{Game} en indirection da den lever op til det krav at den formidler information imellem to parter der ikke kender hinanden.
\\
\subsection{Low Coupling (Lav kobling)}
Et godt eksempel på lav kobling i vores program er imellem vores \textit{Field} og \textit{GameBoard} klasserne. Her er det kun GameBoard der kender til Field. Generelt i vores klassediagram kan man se at der ikke er nogen returnerende pile, hvilket antyder lav kobling.

\subsection{Polymorphism}
Polymorfi bruger vi til vores \textit{Field}, \textit{Ownable}, \textit{Game}, \textit{Fleet}, \textit{LabourCamp}, og \textit{Territory klasser}. Polymorfi er et andet ord for nedarving. Vi nedarver fra Field, for at gøre vores program det mindre, hurtigere og mere overskueligt. Havde vi ikke brugt det, var vi kommet ud i en situation hvor vi ville skulle have lavet en masse ekstra kald for at hente alle data fra andre klasser.

\subsection{Protected Variations}
Vi bruger meget \textit{Protected Variations} i vores kode da det sørger for at vi ikke ved en fejl kommer til at ændre en variabel et sted hvor det ikke er intentionen. Det kan bl. a. ses i vores kode i \textit{Ownable} klassen hvor "price" er protected netop for at undgå dette. 

\subsection{Pure Fabrication}
Vores Field klasse kunne anses for at være \textit{Pure Fabrication}. Egentlig \textit{kan man godt} gøre det uden en Field klasse, det ville bare ødelægge alle former for lav kobling man ellers arbejder hårdt for at opnå i et system.
